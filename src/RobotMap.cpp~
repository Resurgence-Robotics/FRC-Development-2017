// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<PowerDistributionPanel> RobotMap::driveTrainPDP;
std::shared_ptr<AnalogPotentiometer> RobotMap::driveTrainMode_Pot;
std::shared_ptr<DigitalInput> RobotMap::driveTrainAuto_Switch;
std::shared_ptr<CANTalon> RobotMap::driveTrainright2;
std::shared_ptr<CANTalon> RobotMap::driveTrainright1;
std::shared_ptr<CANTalon> RobotMap::driveTrainleft2;
std::shared_ptr<CANTalon> RobotMap::driveTrainleft1;
std::shared_ptr<Encoder> RobotMap::driveTrainRenc;
std::shared_ptr<Encoder> RobotMap::driveTrainLenc;
std::shared_ptr<DigitalInput> RobotMap::intakeIntakeEye;
std::shared_ptr<CANTalon> RobotMap::intakeIntakeArm;
std::shared_ptr<Relay> RobotMap::intakeIntake;
std::shared_ptr<CANTalon> RobotMap::liftLift;
std::shared_ptr<DigitalInput> RobotMap::liftLift_Limit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    driveTrainPDP.reset(new PowerDistributionPanel(16));
    lw->AddSensor("DriveTrain", "PDP", driveTrainPDP);
    
    driveTrainMode_Pot.reset(new AnalogPotentiometer(3, 1.0, 0.0));
    lw->AddSensor("DriveTrain", "Mode_Pot", driveTrainMode_Pot);
    
    driveTrainAuto_Switch.reset(new DigitalInput(9));
    lw->AddSensor("DriveTrain", "Auto_Switch", driveTrainAuto_Switch);
    
    driveTrainright2.reset(new CANTalon(15));
    lw->AddActuator("DriveTrain", "right2", driveTrainright2);
    
    driveTrainright1.reset(new CANTalon(14));
    lw->AddActuator("DriveTrain", "right1", driveTrainright1);
    
    driveTrainleft2.reset(new CANTalon(1));
    lw->AddActuator("DriveTrain", "left2", driveTrainleft2);
    
    driveTrainleft1.reset(new CANTalon(0));
    lw->AddActuator("DriveTrain", "left1", driveTrainleft1);
    
    driveTrainRenc.reset(new Encoder(2, 3, true, Encoder::k4X));
    lw->AddSensor("DriveTrain", "Renc", driveTrainRenc);
    driveTrainRenc->SetDistancePerPulse(1.0);
    driveTrainRenc->SetPIDSourceType(PIDSourceType::kDisplacement);
    driveTrainLenc.reset(new Encoder(4, 5, false, Encoder::k4X));
    lw->AddSensor("DriveTrain", "Lenc", driveTrainLenc);
    driveTrainLenc->SetDistancePerPulse(1.0);
    driveTrainLenc->SetPIDSourceType(PIDSourceType::kDisplacement);
    intakeIntakeEye.reset(new DigitalInput(0));
    lw->AddSensor("Intake", "IntakeEye", intakeIntakeEye);
    
    intakeIntakeArm.reset(new CANTalon(3));
    lw->AddActuator("Intake", "IntakeArm", intakeIntakeArm);
    
    intakeIntake.reset(new Relay(0));
    lw->AddActuator("Intake", "Intake", intakeIntake);
    
    liftLift.reset(new CANTalon(2));
    lw->AddActuator("Lift", "Lift", liftLift);
    
    liftLift_Limit.reset(new DigitalInput(1));
    lw->AddSensor("Lift", "Lift_Limit", liftLift_Limit);
    


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
